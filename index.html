<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"
    />
    <title>Web Barcode Detector with OpenCV.js</title>
    <style>
      #imageContainer {
        max-width: 300px;
        max-height: 300px;
        overflow: auto;
      }

      .fullscreen {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0;
        top: 0;
        background: white;
      }

      #cameraSelect {
        z-index: 999;
        top: 0;
        position: absolute;
      }

      #closeButton {
        z-index: 999;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <h2>Web Barcode Detector with OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <div>
      <button onclick="startLiveScan()">Live scan</button>
      <div id="resultContainer"></div>
      <div class="scanner">
        <canvas id="canvas"></canvas>
        <video
          class="camera"
          id="camera"
          width="640"
          height="480"
          muted
          autoplay="autoplay"
          playsinline="playsinline"
          webkit-playsinline
          style="visibility: hidden"
        ></video>
      </div>
    </div>
    <script type="text/javascript">
      // def update(old):
      //   @np.vectorize
      //   def sum_around(i, j):
      //       return old[max(0, i - 1) : i + 2, max(0, j - 1) : j + 2].sum() - old[i, j]

      //   around = np.fromfunction(sum_around, old.shape, dtype=int)
      //   new = np.where(old, ((2 <= around) & (around <= 3)), (around == 3))
      //   return new

      // cv.Mat -> cv.Mat
      function update(old) {
        // oldと同じサイズの新しい行列を作成する
        let newMat = new cv.Mat();
        old.copyTo(newMat);

        // 各ピクセルを更新する
        for (let i = 0; i < old.rows; i++) {
          for (let j = 0; j < old.cols; j++) {
            // 周囲の合計を計算する
            let sum = 0;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                let ni = i + di;
                let nj = j + dj;

                // 範囲をはみ出さないようにする
                if (ni >= 0 && ni < old.rows && nj >= 0 && nj < old.cols) {
                  sum += old.ucharPtr(ni, nj)[0];
                }
              }
            }

            // 自分自身を引く
            sum -= old.ucharPtr(i, j)[0];

            // ルールに基づいて新しい値を設定する
            let currentValue = old.ucharPtr(i, j)[0];
            if (currentValue) {
              if (sum >= 2 && sum <= 3) {
                newMat.ucharPtr(i, j)[0] = 1;
              } else {
                newMat.ucharPtr(i, j)[0] = 0;
              }
            } else {
              if (sum === 3) {
                newMat.ucharPtr(i, j)[0] = 1;
              } else {
                newMat.ucharPtr(i, j)[0] = 0;
              }
            }
          }
        }

        return newMat;
      }
      var Module = {
        // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
        onRuntimeInitialized() {
          document.getElementById("status").innerHTML = "OpenCV.js is ready.";

          const video = document.getElementById("camera"); // video is the id of video tag
          navigator.mediaDevices
            .getUserMedia({ video: true, audio: false })
            .then(function (stream) {
              video.srcObject = stream;
              video.play();
            })
            .catch(function (err) {
              console.log("An error occurred! " + err);
            });

          let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
          let dst = new cv.Mat(video.height, video.width, cv.CV_8UC4);
          let gray = new cv.Mat();
          let cell = new cv.Mat();
          let cap = new cv.VideoCapture(video);
          let count = 0;
          const detector = new cv.QRCodeDetector();

          const FPS = 15;
          function processVideo() {
            try {
              let begin = Date.now();
              cap.read(src);
              src.copyTo(dst);

              let points = new cv.Mat();
              let straightCode = new cv.Mat();
              detector.detectAndDecode(dst, points, straightCode);

              if (straightCode.size().width > 0) {
                const resized = new cv.Mat();
                cv.resize(straightCode, resized, new cv.Size(50, 50));

                const binary = new cv.Mat();
                cv.threshold(resized, binary, 127, 1, cv.THRESH_BINARY);

                if (cell.size().width === 0) {
                  cell = binary;
                } else {
                  cell = update(cell);
                }

                const showCell = new cv.Mat();
                cell.convertTo(showCell, cv.CV_8U);
                let binaryData = showCell.data;

                for (let i = 0; i < binaryData.length; i++) {
                  binaryData[i] = (1 - binaryData[i]) * 255;
                }

                cv.imshow("canvas", showCell);
              } else {
                cv.imshow("canvas", dst);
              }

              let delay = 1000 / FPS - (Date.now() - begin);
              setTimeout(processVideo, delay);
            } catch (err) {
              console.error(err);
            }
          }

          // schedule the first one.
          setTimeout(processVideo, 0);
        },
      };
    </script>
    <script
      async
      src="https://docs.opencv.org/4.8.0/opencv.js"
      type="text/javascript"
    ></script>
  </body>
</html>
